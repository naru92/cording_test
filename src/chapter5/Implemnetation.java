package chapter5;

import java.util.Scanner;

public class Implemnetation {
    //구현이란 , 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정
    
    //풀이는 쉽지만, 소스코드로 옮기기 어려운 문제
    
    /*
     * 사용 언어에 따라 난이도가 상이함, 많이 만들어봐야함(라이브러리 숙지)
     * 알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제
     * 실수 연산을 다루고, 특정 소수점 자리까지 출력해야 하는 문제
     * 문자열을 특정한 기준에 따라서 끊어 처리해야 하는 문제
     * 적절한 라이브러리를 찾아서 사용해야 하는 문제 
    */
    
    // 일반 적으로 알고리즘 문제에서의 2차원 공간은 행렬(Matrix)의 의미로 사용됩니다.
    
    /*
     * 상하좌우 문제
     * 여행가 A는 N x N 크기의 정사각형 공간 위에 서 있습니다. 이 공간은 1 x 1 크기의 정사각형으로 나누어져
     * 있습니다. 가장 왼쪽 위 좌표는 (1,1) 이며 가장 오른쪽 아래 좌표는 (N,N)에 해당합니다. 여행가 A는
     * 상, 하, 좌, 우 방향으로 이동할 수 있으며, 시작 좌표는 항상(1,1) 입니다. 우리 앞에는 여행가 A가 이동할 계획이
     * 적힌 계획서가 놓여 있습니다.
     * 
     * 계획서에는 하나의 줄에 띄어쓰기를 기준으로 하여 L, R, U, D 중 하나의 문자가 반복적으로 적혀 있습니다.
     * 각 문자의 의미는 다음과 같습니다.
     
     -L : 왼쪽으로 한 칸 이동
     -R : 오른쪽으로 한 칸 이동
     -U : 위로 한 칸 이동
     -D : 아래로 한 칸 이동
     
     -이때 여행가 A가 N x N 크기의 정사각형 공간을 벗어나는 움직임은 무시 됩니다.
     
     *풀이시간 15분
     *시간 제한 2초
     *메모리 제한 128MB
     
     *입력조건
     *첫째 줄에 공간의 크기를 나타내는 N이 주어집니다 (1<= N <= 100)
     *둘째 줄에 여행가 A가 이동할 계획서 내용이 주어집니다.(1<= 이동횟수 <= 100)
     
     *출력조건
     *첫째 줄에 여행가 A가 최종적으로 도착할 지점의 좌표(X,Y)를 공백을 기준으로 구분하여 출력합니다
     
     *입력 예시                 출력예시
     *5                       3 4 
     *R R R U D D
    */
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();//2차원 배열의 크기
        
        sc.nextLine();//버퍼 지우기
        String[] movePlans = sc.nextLine().split(" "); //공백을 기준으로 자름
        int x = 1 , y = 1;
        
        // L, R, U, D에 따른 이동 방향
        int[] dx = {0, 0, -1, 1};
        int[] dy = {-1, 1, 0, 0};
        char[] moveType = {'L','R','U','D'};
        
        //이동 계획을 하나씩 확인
        for(int i=0 ; i< movePlans.length; i++) {
            char movePlan = movePlans[i].charAt(0);
            //이동 후 좌표 구하기
            int nx = -1, ny = -1;
            for(int j =0 ; j< 4; j++) {
                if(movePlan == moveType[j]) {
                    nx = x + dx[j];
                    ny = y + dy[j];
                }
            }
            //공간을 벗어나는 경우 무시
            if(nx < 1 || ny <1 || nx> n || ny > n ) {
                continue;
            }
            x = nx;
            y = ny;
        }
        System.out.println(x + " " + y);
        sc.close();
    }
}
